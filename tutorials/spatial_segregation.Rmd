---
title: "Simulating Segregation"
output: html_notebook
---

Let's start with a simple scenario in which we have city with 100000 inhabitants, distributed across 400 grid cells representing city blocks on a 24x24 square grid.

Let's start by assigning each grid cell to a neighborhood.

```{r}
dissimilarity <- function(x) {
  total_a <- sum(x)
  total_b <- sum(1-x)
  d <- 0.5*sum(abs((x/total_a) - ((1-x)/total_b)))
  return(d)
}

```

```{r}
isolation <- function(x) {
  total_a <- sum(x)
  d <- sum((x**2)/total_a)
  return(d)
}
```

```{r}
require(dplyr)
require(ggplot2)
require(spdep)

## Make an empty matrix
d <- 24
neighborhood_mat <- matrix(0, d, d)
neighborhood_mat[1:length(neighborhood_mat)] <- runif(length(neighborhood_mat), 0.3, 0.41)

neighborhood_mat[,1:floor(d/2)] <- runif(length(neighborhood_mat)/2, 0.5, 0.6)

neighborhood_df <- expand.grid(x = 1:d, y = 1:d)
neighborhood_df$group <- as.vector(neighborhood_mat[cbind(neighborhood_df$y, neighborhood_df$x)])

g <- ggplot(neighborhood_df, aes(x = x, y = y, fill = group)) + 
  geom_raster() + 
  theme_bw() + 
  coord_equal()
plot(g)
```

```{r}
## Define a function to calculate Moran's I for an 
## arbitrary vector of values on a square grid

morans_grid <- function(d, x) {
  require(spdep)
  
  neighbors <- nb2listw(cell2nb(d,d))
  
  return(moran(x, neighbors, 1, 1))

}

```


```{r}
morans_grid(d, neighborhood_df$group)$I
```

```{r}
## Randomize

random_df <- neighborhood_df
random_df$group <- sample(neighborhood_df$group)

g <- ggplot(random_df, aes(x = x, y = y, fill =group)) + 
  geom_raster() + 
  theme_bw() + 
  coord_equal()
plot(g)

```


```{r}

## Permutation test on grid values
nsamp <- 5000
moran_values <- rep(0, nsamp)
neighbors <- nb2listw(cell2nb(d,d))
for (i in 1:nsamp) {
  moran_values[i] <- moran(sample(neighborhood_df$group), neighbors, 1, 1)$I
}

hist(moran_values, breaks = 100)
```