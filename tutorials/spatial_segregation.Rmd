---
title: "Simulating Segregation"
output: html_notebook
---

Let's start with a simple scenario in which we have city with 100000 inhabitants, distributed across 400 grid cells representing city blocks on a 24x24 square grid.

Let's start by assigning each grid cell to a neighborhood.

```{r}
dissimilarity <- function(x,n) {
  total_a <- sum(x)
  total_b <- sum(n-x)
  d <- 0.5*sum(abs((x/total_a) - ((n-x)/total_b)))
  return(d)
}

```

```{r}
isolation <- function(x,n) {
  x <- x[n > 0]
  n <- n[n > 0]
  total_a <- sum(x)
  d <- sum((x/total_a)*(x/n))
  return(d)
}
```

```{r}
require(dplyr)
require(ggplot2)
require(spdep)

## Make an empty matrix
d <- 8
neighborhood_mat <- matrix(1, d, d)
ncell <- length(neighborhood_mat)

A <- 10000
B <- 500
#neighborhood_mat[1:ncell] <- #rbinom(ncell, n, runif(ncell, 0.2, 0.21))

neighborhood_mat[,1:floor(d/4)] <- 1.1#rbinom(ncell/2, n, runif(ncell, 0.26, 0.27))

neighborhood_df <- expand.grid(x = 1:d, y = 1:d)
cell_rates <- as.vector(neighborhood_mat[cbind(neighborhood_df$y, neighborhood_df$x)])
neighborhood_df$b <- rmultinom(1, B, cell_rates)
neighborhood_df$a <- rmultinom(1, A, 1/cell_rates)

neighborhood_df$n <- neighborhood_df$a + neighborhood_df$b
neighborhood_df$group <- neighborhood_df$b/neighborhood_df$n

g <- ggplot(neighborhood_df, aes(x = x, y = y, fill = group)) + 
  geom_raster() + 
  theme_bw() + 
  coord_equal()
plot(g)
```

```{r}

iso_val <- isolation(neighborhood_df$b, neighborhood_df$n)

## Generate random allocations to cells based on pop'n distribution
p <- sum(neighborhood_df$b)/sum(neighborhood_df$n)

## Generate allocations assuming a completely uniform distribution
nsamp <- 5000
rand_isolation <- rep(0, nsamp)
for (i in 1:nsamp) {
  random_a  <- rmultinom(1, A, rep(1, ncell))
  random_b <- rmultinom(1, B, rep(1, ncell))
  random_n <- random_a + random_b
  rand_isolation[i] <- isolation(random_b, random_a+random_b)/p
}

g <- ggplot(data = data.frame(x=rand_isolation),aes(x=x)) + 
  geom_histogram(bins = 50) + 
  geom_vline(xintercept = iso_val/p) + 
  #geom_vline(xintercept = p, linetype = "dashed") + 
  theme_bw()
plot(g)

```

```{r}
## Define a function to calculate Moran's I for an 
## arbitrary vector of values on a square grid

morans_grid <- function(d, x) {
  require(spdep)
  
  neighbors <- nb2listw(cell2nb(d,d))
  
  return(moran(x, neighbors, 1, 1))

}

```


```{r}
morans_grid(d, neighborhood_df$group)$I
```

```{r}
## Randomize

random_df <- neighborhood_df
random_df$group <- sample(neighborhood_df$group)

g <- ggplot(random_df, aes(x = x, y = y, fill =group)) + 
  geom_raster() + 
  theme_bw() + 
  coord_equal()
plot(g)

```


```{r}

## Permutation test on grid values
nsamp <- 5000
moran_values <- rep(0, nsamp)
neighbors <- nb2listw(cell2nb(d,d))
for (i in 1:nsamp) {
  moran_values[i] <- moran(sample(neighborhood_df$group), neighbors, 1, 1)$I
}

hist(moran_values, breaks = 100)
```